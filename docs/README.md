# 기능 목록

## 구현할 기능들

- 게임 시작을 알리는 메시지 출력
- 게임 실행
  - 정답숫자를 생성함
  - 야구숫자를 입력받음
    - 야구숫자를 입력해달라는 메시지 출력
    - 야구숫자를 입력받음
  - 볼카운팅 결과를 생성
    - 야구숫자의 각 자릿수를 정답숫자와 비교, 취합
  - 볼카운팅 결과를 출력
  - 게임 종료 판단
    - 풀카운트면 게임 종료 절차
      - 풀카운트인지 확인
      - 게임 재시작/종료 메시지 출력
      - 게임 재시작/종료 입력받음
    - 풀카운트가 아니면, 계속 진행
    - 게임 재시작 시, '게임 시작' 단계부터 다시 실행
    - 게임 종료 시, 추가 동작 없이 동료
    - 계속 진행 시, '게임 시작 - 야구숫자를 입력받음' 단계부터 다시 반복

## 수행 리팩토링 목록
- 리터럴 상수 제거
- 경계 정리
  - 입력, 난수생성 기능이 외부 라이브러리를 직접 의존하고 있다.
  - 콘솔 출력 기능이 로직에 직접 포함되어 있다.
  - 입력, 난수생성, 출력 기능은 각각의 이유로 분리되는 편이 적절하다.
- 어플리케이션 실행과 로직을 분리하기
  - 현재 Application.java가 어플리케이션의 로직까지 가지고 있다.
  - 분리하는 것이 좋겠다고 판단했다. Application은 앱의 정상적인 실행과 실행 중 발생하여 최상위까지 올라오는 예외에 대한 책임만을 가지도록 하자.
- WinningNumbers와 BaseballNumbers를 테스트 가능하도록 수정하기.
  - '번호' 객체 추출.
    - '번호' 객체는 자릿수와 번호, 그리고 '번호 생성방법'을 필드로 갖는다.
    - '번호 생성방법'은 '정답번호 생성방법', '야구숫자 생성방법'을 구체타입으로 갖는 인터페이스다.

## 참고
- 야구숫자:
  - 숫자여야 함
  - 세 자리여야 함
  - 각 자리가 중복되지 않아야 함
  - 양수여야 함
- 볼카운팅 과정:
  - 정답숫자와 포함은 되어있는데 자릿수가 일치하지 않으면 '볼'
  - 정답숫자와 포함이 되어있고 자릿수도 일치하면 '스트라이크'
  - 정답숫자에 포함이 되어있지 않으면 '낫싱'
- 풀카운트:
  - 볼카운팅(BallCount)이 3스트라이크인 경우를 말함

## 고민들

### 2023-10-19
- '게임 종료 판단' 단계를 어떻게 구성하면 좋을지 모르겠다. 진행 중인지 재시작인지에 따라서 다시 시작되는 지점이 다른 것이 고민되는 지점.
- 테스트 코드는 언제 추가해야 하지?
- 레코드 이렇게 쓰는게 맞나? '볼카운팅'의 구현에 썼는데, 이럴때 쓰는게 적절한건가 모르겠다.
  - 레코드는 필드를 가질 수 없다는 특징을 알게 되었다.

### 2023-10-20
- 다른 코드들을 보면 Application에서 어떤 객체를 생성해서 실행하는 것으로 시작한다. 아래처럼.
```java
public class Application {
    public static void main(String[] args) {
        SomeGame game = new SomeGame();
        game.play();
    }
}
```
  - 꼭 이러한 패턴이어야 하는 이유는 뭘까? Application이라는 이름보다 '게임'이란 걸 수행한다는 걸 명확하게 하기 위함일 수도 있지만, 이 앱이 '어떤 게임에 관한 것'이라는 건 이미 패키지명 수준에서 충분히 설명되지 않나?
  - 지금 상황을 예로 들면, java-baseball 패키지의 Application은 java-baseball 앱이라는 걸 이미 직관적으로 표현하고 있는게 아닐까?
  - 하지만 로직 수행 책임과 어플리케이션의 동작 책임은 다르다.
- java.util.Objects#equals()를 여러번 사용하는 코드가 있어서, Objects를 static import 하려고 했는데 안된다. 이유가 뭘까?
- TODO 주석이 제대로 작성이 안된다. 인텔리제이 문제인 듯 하다. 대신할 만한 기능이 있나?...
- WinningNumbers와 BaseballNumbers를 테스트 가능하도록 수정하기.
  - 생성자 안에 생성하는 로직이 담겨 있어서 그렇다. 어떻게 분리할까?
  - 생성된 번호의 타입(List<Integer>)과 최대 길이 제한 상수(int MAX_SIZE)가 동일하게 있다.
    - 어쩌면 같은 개념의 객체 하나가 공통적으로 양 클래스에 내포되어있다는 신호 아닐까?
    - 같은 개념의 객체를 생성하는데, 두 가지 경우의 생성 방법을 활용할 수 있도록.
    - 산책하고 오니까 아이디어가 떠올랐다: 간단하게 보기 - MAX_SIZE와 numbers를 필드로 갖는 객체 뽑기. 근데! 해당 객체는 '숫자 생성방법'도 필드로 갖는다. '숫자 생성방법'은 인터페이스로, '정답숫자 생성방법', '야구숫자 생성방법'이라는 구체클래스가 속하게 된다.
